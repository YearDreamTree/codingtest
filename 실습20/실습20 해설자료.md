# 실습20 해설자료
## ✅ 핵심 개념 정리 (Python)

이 문제는 2차원 리스트에서 특정 정보(출석번호)만 추출하여 정렬하는 기본적인 데이터 처리 작업입니다. 파이썬의 리스트 처리 방법과 정렬 함수에 대한 이해가 필요합니다.

* **리스트 (List `[]`)**:
    * 파이썬의 기본적인 순서가 있는 자료구조입니다.
    * **2차원 리스트 (List of Lists)**: 리스트의 각 요소가 또 다른 리스트인 형태입니다. `book = [["1", "이름1"], ["3", "이름2"], ...]` 와 같은 구조입니다.
    * **인덱싱 (Indexing)**: 리스트의 특정 요소에 접근하는 방법입니다.
        * `리스트[i]`: 리스트의 `i`번째 요소에 접근합니다 (인덱스는 0부터 시작).
        * `리스트[i][j]`: 2차원 리스트의 경우, `i`번째 내부 리스트의 `j`번째 요소에 접근합니다. 예를 들어 `book[0][0]`은 첫 번째 내부 리스트(`["1", "엘리스 토끼"]`)의 첫 번째 요소인 `"1"`에 접근합니다.
* **반복문 (`for` loop)**:
    * 리스트와 같은 반복 가능한 객체의 요소를 하나씩 순회하거나, `range()` 함수와 함께 인덱스를 이용하여 반복 작업을 수행합니다.
    * `range(len(리스트))`: 0부터 `리스트길이 - 1` 까지의 정수 시퀀스를 만들어, `for i in range(len(리스트)):` 형태로 사용하면 리스트의 모든 인덱스 `i`를 순서대로 사용할 수 있습니다.
* **리스트 메소드**:
    * `.append(요소)`: 리스트의 맨 뒤에 새로운 `요소`를 추가합니다.
* **내장 함수 `sorted(iterable)`**:
    * 리스트, 튜플 등 반복 가능한(iterable) 객체를 인자로 받아서, 그 요소들을 **오름차순**으로 정렬한 **새로운 리스트**를 반환합니다. 원본 객체는 변경되지 않습니다.
    * **문자열 정렬**: `sorted()` 함수에 문자열로 구성된 리스트를 넣으면, 기본적으로 **사전 순서 (lexicographical order)**로 정렬합니다. 예를 들어 `sorted(['apple', 'banana', 'ant'])`는 `['ant', 'apple', 'banana']`를 반환합니다. 숫자 형태의 문자열의 경우에도 사전 순으로 정렬됩니다 (`sorted(['3', '1', '10', '2'])` -> `['1', '10', '2', '3']`).
    * 이 문제의 예시 데이터(`"1"`, `"2"`, `"3"`, `"5"`, `"6"`, `"7"`, `"9"`)는 모두 한 자리 숫자 문자열이거나, 사전 순 정렬 결과가 숫자 크기 순서와 일치하는 경우이므로, 문자열 상태로 `sorted()`를 사용해도 원하는 결과를 얻을 수 있습니다.
* **(참고) 리스트의 `.sort()` 메소드**:
    * `리스트.sort()`는 리스트 자체를 내부적으로(in-place) 정렬하고 아무것도 반환하지 않습니다 (`None` 반환). `sorted()` 함수와 혼동하지 않도록 주의해야 합니다. 정답 코드는 `sorted()` 함수를 사용합니다.

## ✅ 문제 해결 아이디어

문제의 목표는 `book`이라는 2차원 리스트에서 각 학생 정보(내부 리스트)의 첫 번째 요소인 출석번호(문자열)만 모두 뽑아내어, 이 출석번호들을 오름차순으로 정렬한 새로운 리스트를 반환하는 것입니다.

정답 코드의 해결 전략은 다음과 같습니다.

1.  **출석번호 추출용 리스트 준비**: 추출된 출석번호들을 담을 새로운 빈 리스트(`newBook`)를 만듭니다.
2.  **원본 리스트 순회 및 추출**: `for` 반복문과 `range(len(book))`을 사용하여 원본 `book` 리스트의 인덱스 `i`를 0부터 끝까지 순회합니다.
3.  각 인덱스 `i`에 대해, `book[i]`는 내부 리스트(예: `["1", "엘리스 토끼"]`)를 나타냅니다. 이 내부 리스트의 첫 번째 요소(`[0]`)인 출석번호 문자열(`book[i][0]`)을 가져옵니다.
4.  가져온 출석번호 문자열을 `newBook` 리스트에 `.append()` 메소드를 사용하여 추가합니다.
5.  **정렬**: 반복문이 끝나면 `newBook` 리스트에는 모든 학생의 출석번호 문자열이 원래 순서대로 담겨있게 됩니다. 이제 `sorted()` 함수를 `newBook`에 적용하여 요소들을 오름차순(사전 순)으로 정렬한 **새로운 리스트**를 얻습니다.
6.  **결과 할당 및 반환**: `sorted()` 함수가 반환한 새로 정렬된 리스트를 다시 `newBook` 변수에 할당하고, 이 최종 정렬된 리스트를 함수 결과로 반환합니다.

## ✅ `filterNum` 함수 구현 상세

정답 코드가 위 아이디어를 어떻게 구현하는지 단계별로 살펴보겠습니다.

1.  **빈 리스트 초기화**:
    ```python
    newBook = []
    ```
    * 추출된 출석번호들을 저장할 공간을 마련합니다.

2.  **반복문을 이용한 추출**:
    ```python
    # 0부터 book 리스트 길이 - 1 까지 인덱스 i를 순회
    for i in range(len(book)):
        # book의 i번째 요소(내부 리스트)의 0번째 요소(출석번호 문자열)를 newBook에 추가
        newBook.append(book[i][0])
    ```
    * `book[i]`를 통해 각 학생 정보 리스트에 접근하고, `[0]`을 통해 그 리스트의 첫 번째 요소인 출석번호 문자열을 정확히 가져오는 것이 중요합니다.

3.  **정렬**:
    ```python
    # sorted() 함수는 newBook 리스트를 정렬한 '새로운' 리스트를 반환함
    # 이 새로운 리스트를 다시 newBook 변수에 저장
    newBook = sorted(newBook)
    ```
    * `sorted(newBook)` 호출 시, `newBook`에 들어있는 문자열들이 사전 순서에 따라 정렬됩니다. 예시 데이터의 경우 `"1"`, `"2"`, `"3"`, `"5"`, `"6"`, `"7"`, `"9"` 순서가 됩니다.
    * `sorted()`는 새 리스트를 반환하므로, 결과를 다시 `newBook`에 할당해야 정렬된 결과를 변수에 저장할 수 있습니다.

4.  **반환**:
    ```python
    return newBook
    ```
    * 최종적으로 정렬된 출석번호 문자열 리스트를 반환합니다.

## ✅ (참고) 더 간결한 방법: 리스트 컴프리헨션

위 코드의 추출과 정렬 부분을 리스트 컴프리헨션을 사용하면 더 간결하게 작성할 수 있습니다.

```python
def filterNum(book):
    # 1. 리스트 컴프리헨션으로 출석번호(item[0])만 추출하여 리스트 생성
    numbers_only = [item[0] for item in book]
    # 2. 추출된 리스트를 sorted() 함수로 정렬하여 바로 반환
    return sorted(numbers_only)

# 또는 더 줄여서:
def filterNum(book):
    return sorted([item[0] for item in book])
```
* `[item[0] for item in book]` : `book` 리스트의 각 내부 리스트 `item`에 대해, 그 첫 번째 요소 `item[0]`(출석번호)만 뽑아서 새로운 리스트를 만듭니다.
* `sorted(...)`: 이렇게 만들어진 출석번호 리스트를 바로 정렬하여 반환합니다. 이 방식이 더 파이썬스럽고 효율적일 수 있습니다.

## ✅ 전체 코드 구현

(정답 코드와 동일)
```python
book = [
    ["1", "엘리스 토끼"],
    ["3", "모자장수"],
    ["6", "캐터필러"],
    ["5", "하트여왕"],
    ["2", "도도새"],
    ["9", "신발장수"],
    ["7", "모자 쓴 행인"],
]

def filterNum(book):
    newBook = [] # 출석번호를 저장할 빈 리스트

    # book 리스트의 각 요소(내부 리스트)를 순회하며
    for i in range(len(book)):
        # 내부 리스트의 첫 번째 요소(출석번호 문자열)를 newBook에 추가
        newBook.append(book[i][0])

    # newBook 리스트의 요소(문자열)들을 오름차순(사전순)으로 정렬한 '새 리스트' 생성
    newBook = sorted(newBook)

    # 정렬된 리스트 반환
    return newBook

# 출력 예시를 확인하기 위한 코드입니다.
print(filterNum(book))
```

## 🧾 입출력 예시 설명

* **입력:** `book = [["1", "..."], ["3", "..."], ["6", "..."], ["5", "..."], ["2", "..."], ["9", "..."], ["7", "..."]]`
* **처리 과정:**
    1. `newBook = []` 초기화.
    2. 반복문 실행:
        * `i=0`: `newBook.append(book[0][0])` -> `newBook`에 `"1"` 추가.
        * `i=1`: `newBook.append(book[1][0])` -> `newBook`에 `"3"` 추가.
        * ... (반복) ...
        * `i=6`: `newBook.append(book[6][0])` -> `newBook`에 `"7"` 추가.
    3. 반복문 종료 후 `newBook`은 `['1', '3', '6', '5', '2', '9', '7']` 상태.
    4. `sorted(newBook)` 호출: `['1', '3', '6', '5', '2', '9', '7']`을 사전 순으로 정렬한 새 리스트 `['1', '2', '3', '5', '6', '7', '9']` 반환.
    5. `newBook = ['1', '2', '3', '5', '6', '7', '9']` 로 재할당됨.
    6. 함수는 `['1', '2', '3', '5', '6', '7', '9']` 를 반환.
* **`print()` 함수 실행:** 함수가 반환한 리스트 `['1', '2', '3', '5', '6', '7', '9']`를 화면에 출력합니다.
* **최종 출력:**
    ```
    ['1', '2', '3', '5', '6', '7', '9']
    ```

## ❗ 자주 하는 실수

* **2차원 리스트 인덱싱 오류**: `book[i]` 까지만 접근하거나 `book[i][1]` (이름)을 잘못 사용하는 경우. 정확히 출석번호가 있는 `book[i][0]`을 사용해야 합니다.
* **`sorted()` 함수와 `.sort()` 메소드 혼동**: `newBook = newBook.sort()` 와 같이 작성하면 `newBook`에는 정렬된 리스트가 아닌 `None` 값이 저장됩니다. `sorted()`는 **새로운 정렬된 리스트를 반환**하므로 그 결과를 변수에 다시 할당해야 하고, `.sort()`는 **원본 리스트를 직접 변경**하고 `None`을 반환합니다.
* **타입 변환 오해 또는 불필요한 변환**: 문제에서는 출석번호를 **문자열 형태**로 반환하라고 요구했습니다. 따라서 추출한 문자열 `"1"` 등을 `int(1)`로 바꿀 필요가 없으며, 오히려 변환 후 다시 문자열로 바꾸는 번거로움이 생길 수 있습니다. 문자열 상태로 정렬해도 예시 데이터에서는 원하는 결과가 나오므로 그대로 두는 것이 좋습니다. (만약 출석번호가 `"10"` 처럼 여러 자리 수이고 숫자 크기대로 정렬해야 한다면, `sorted(newBook, key=int)` 처럼 정렬 기준을 정수로 변환하여 비교하도록 `key`를 지정해야 합니다.)
* **반환값 형식 오류**: 최종 결과를 리스트가 아닌 다른 형식(예: 튜플)으로 반환하는 경우입니다.

2차원 리스트의 구조를 이해하고 원하는 데이터를 정확히 추출하는 능력, 그리고 `sorted()` 함수의 사용법(특히 문자열 정렬 방식)을 아는 것이 중요한 문제입니다. 리스트 컴프리헨션을 사용하면 코드를 더 간결하게 만들 수 있습니다.