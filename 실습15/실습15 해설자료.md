# 실습15 해설자료
## ✅ 핵심 개념 정리 (Python)

이 문제는 두 개의 리스트(게임 로그)를 비교하여 특정 조건을 만족하는 항목을 찾는 프로그래밍의 기본적인 작업을 다룹니다. 필요한 파이썬 개념은 다음과 같습니다.

* **리스트 (List `[]`)**:
    * 순서가 있는 여러 개의 데이터를 담는 자료구조입니다.
    * **인덱스(Index)**: 리스트 내 각 항목의 위치를 나타내는 번호 (0부터 시작). `my_list[i]` 와 같이 대괄호를 사용하여 특정 인덱스의 요소에 접근합니다.
    * `len(리스트)`: 리스트에 포함된 요소의 개수(길이)를 반환합니다.
* **`range(숫자)` 함수**:
    * 0부터 `숫자 - 1`까지의 정수 시퀀스를 생성합니다. 주로 `for` 반복문과 함께 쓰여 특정 횟수만큼 반복하거나 리스트의 인덱스를 순서대로 얻는 데 사용됩니다. 예: `range(5)`는 0, 1, 2, 3, 4를 생성. `range(len(my_list))`는 리스트의 모든 유효한 인덱스를 생성합니다.
* **반복문 (`for` loop)**:
    * `for 변수 in 반복가능객체:` 형태로, 리스트, `range()` 객체 등의 각 요소를 순서대로 `변수`에 할당하며 코드 블록을 반복 실행합니다. `for i in range(len(log1)):` 구문은 리스트 `log1`의 인덱스 `i`를 0부터 마지막까지 순차적으로 사용하게 해줍니다.
* **문자열 (String) 메소드**:
    * `startswith(prefix)`: 특정 문자열이 주어진 `prefix`(시작 문자열)로 시작하는지 여부를 검사하여 `True` 또는 `False`를 반환합니다. 대소문자를 구분합니다. 예: `"#123".startswith('#')`는 `True`를 반환합니다.
* **조건문 (`if-elif`)**:
    * 주어진 조건의 참/거짓에 따라 코드 실행 흐름을 제어합니다. `if` 조건이 참이면 해당 블록을 실행하고, 거짓이면 다음 `elif` 조건을 검사합니다. `elif` 조건이 참이면 해당 블록을 실행합니다. 둘 다 거짓이면 넘어갑니다.
* **함수 (`def`, `return`)**:
    * `def 함수명(매개변수):`: 특정 작업을 수행하는 코드 블록을 정의합니다.
    * `return 값`: 함수 실행을 즉시 종료하고 지정된 `값`을 함수 호출 지점으로 반환합니다. 함수 내에서 `return` 문이 실행되면 그 이후의 코드는 실행되지 않습니다.
* **f-string (Formatted String Literal)**:
    * 문자열 앞에 `f`를 붙이고, 문자열 내부에 `{변수명}` 형태로 변수 값을 직접 넣어 문자열을 만드는 편리한 방법입니다. 예: `f"이름: {name}, 턴: {turn}"`

## ✅ 문제 해결 아이디어

문제의 목표는 두 플레이어(엘리스 토끼, 모자 장수)의 게임 로그 리스트(`log1`, `log2`)를 받아서, 누가 몇 번째 턴에 회피 기술('#'로 시작하는 로그)을 사용했는지 찾아 "이름, 턴수" 형태의 문자열로 반환하는 것입니다.

다음과 같은 중요한 단서와 제약 조건이 주어졌습니다.

* 두 로그 리스트의 길이는 항상 같습니다 (턴제 게임).
* 회피 기술('#')은 두 플레이어를 통틀어 **정확히 한 번만** 사용됩니다.

이 조건들을 활용한 해결 전략은 다음과 같습니다.

1.  **턴 동기화 순회**: 두 로그 리스트의 길이가 같으므로, `for` 반복문과 `range(len(log1))`을 사용하여 0번 턴(인덱스 0)부터 마지막 턴까지 순서대로 확인합니다. 각 반복에서의 인덱스 `i`는 현재 확인 중인 턴 번호(0부터 시작)를 의미합니다.
2.  **순차적 확인**: 각 턴 `i`에 대해,
    * **먼저** 엘리스 토끼의 로그(`log1[i]`)가 '#'로 시작하는지 `startswith('#')`를 이용해 확인합니다.
    * 만약 맞다면, 더 이상 확인할 필요가 없습니다. 문제 조건에 따라 다른 곳에서는 '#'이 나올 수 없기 때문입니다. 즉시 "엘리스 토끼, {i+1}" 형태의 문자열을 `return`하여 함수를 종료합니다. (이때, 턴 수는 1부터 시작하므로 인덱스 `i`에 1을 더한 `i+1`을 사용합니다.)
    * 만약 엘리스 토끼의 로그가 '#'로 시작하지 않았다면, **그 다음으로** 모자 장수의 로그(`log2[i]`)가 같은 턴 `i`에서 '#'로 시작하는지 확인합니다.
    * 만약 맞다면, 마찬가지로 더 이상 확인할 필요 없이 즉시 "모자 장수, {i+1}" 형태의 문자열을 `return`하고 함수를 종료합니다.
3.  **반환 보장**: 문제에서 회피 기술이 반드시 한 번 사용된다고 보장했으므로, 위 반복문은 항상 '#'을 찾아 해당 `if` 또는 `elif` 블록 안에서 `return`을 만나 종료됩니다. 따라서 반복문이 끝난 후 별도의 `return` 문은 필요하지 않습니다.

## ✅ `checkLog` 함수 구현 상세

정답 코드가 위 아이디어를 어떻게 구현하는지 자세히 보겠습니다.

```python
def checkLog(log1, log2):
    # 0부터 log1의 길이 - 1 까지의 인덱스를 순회 (각 i는 턴 번호 - 1)
    for i in range(len(log1)):
        # 현재 턴 i에서 log1(엘리스 토끼 로그)이 '#'으로 시작하는가?
        if log1[i].startswith('#'):
            # 맞다면, f-string을 이용해 "엘리스 토끼, (i+1)" 문자열 생성 후 즉시 반환!
            return f"엘리스 토끼, {i+1}"

        # log1[i]가 '#'로 시작하지 않았다면, 현재 턴 i에서 log2(모자 장수 로그)가 '#'으로 시작하는가?
        elif log2[i].startswith('#'):
            # 맞다면, f-string을 이용해 "모자 장수, (i+1)" 문자열 생성 후 즉시 반환!
            return f"모자 장수, {i+1}"
    # (문제 조건상 이 부분은 실행될 일이 없음)
```

* `range(len(log1))`을 통해 0부터 시작하는 인덱스 `i`를 얻습니다.
* `log1[i].startswith('#')` : `i`번째 턴의 엘리스 토끼 로그가 '#'로 시작하는지 검사합니다.
* `return f"엘리스 토끼, {i+1}"`: 만약 위 조건이 참이면, f-string을 사용하여 "엘리스 토끼, " 뒤에 실제 턴 번호 (`i`에 1을 더한 값)를 붙여 문자열을 만들고, 이 문자열을 반환하며 함수 실행을 즉시 종료합니다.
* `elif log2[i].startswith('#')`: 만약 첫 번째 `if` 조건이 거짓이었을 경우에만 실행됩니다. `i`번째 턴의 모자 장수 로그가 '#'로 시작하는지 검사합니다.
* `return f"모자 장수, {i+1}"`: 만약 `elif` 조건이 참이면, 모자 장수의 이름과 턴 번호(`i+1`)로 문자열을 만들어 반환하고 함수를 즉시 종료합니다.

## ✅ 전체 코드 구현

```python
# 엘리스 토끼의 기록입니다.
eliceCommandLog = ["@2457","!4679476","@24562457","!3657","@5897","!2547","#679647"]

# 모자 장수의 기록입니다.
hatSellerCommandLog = ["@356883","@35673","@247987","@35683469","!4697","!972563","!32670"]

# 주어진 지시사항에 맞추어 checkLog() 함수를 구현하세요.
def checkLog(log1, log2):
    # 0번 턴부터 마지막 턴까지 인덱스 i를 순회합니다.
    for i in range(len(log1)):
        # i번째 턴의 엘리스 토끼 로그(log1[i])가 '#'으로 시작하는지 확인합니다.
        if log1[i].startswith('#'):
            # 맞다면, "엘리스 토끼, (턴 번호)" 형식의 문자열을 반환하고 함수를 종료합니다.
            # 턴 번호는 0부터 시작하는 인덱스 i에 1을 더합니다.
            return f"엘리스 토끼, {i+1}"

        # 엘리스 토끼 로그가 '#'이 아니었다면,
        # i번째 턴의 모자 장수 로그(log2[i])가 '#'으로 시작하는지 확인합니다.
        elif log2[i].startswith('#'):
            # 맞다면, "모자 장수, (턴 번호)" 형식의 문자열을 반환하고 함수를 종료합니다.
            return f"모자 장수, {i+1}"

    # 문제 조건에 따라 이 부분은 실행되지 않지만, 만약 '#' 로그가 없는 경우를
    # 고려한다면 여기에 기본 반환값(예: None 또는 오류 메시지)을 넣을 수 있습니다.

# 올바른 작동을 확인하기 위한 코드입니다.
print(checkLog(eliceCommandLog,hatSellerCommandLog))
```

## 🧾 입출력 예시 설명

* **입력 데이터:**
    * `eliceCommandLog = ["@2457", ..., "#679647"]` (7개 요소, 인덱스 0~6)
    * `hatSellerCommandLog = ["@356883", ..., "!32670"]` (7개 요소, 인덱스 0~6)
* **`checkLog` 함수 실행:**
    1. `for i in range(7)`: `i`가 0부터 6까지 변합니다.
    2. `i = 0`: `log1[0]` ("@2457")은 '#' 시작 아님. `log2[0]` ("@356883")도 '#' 시작 아님.
    3. `i = 1`: `log1[1]` ("!...") 아님. `log2[1]` ("@...") 아님.
    4. ... (계속 반복) ...
    5. `i = 5`: `log1[5]` ("!...") 아님. `log2[5]` ("!...") 아님.
    6. `i = 6`:
        * `if log1[6].startswith('#')`: `log1[6]`은 `"#679647"`이므로 `True`.
        * `if` 조건이 만족되었으므로 해당 블록 실행.
        * `return f"엘리스 토끼, {6+1}"` 실행. 즉, `"엘리스 토끼, 7"` 문자열을 반환하고 함수 즉시 종료.
* **`print()` 함수 실행:** `checkLog` 함수가 반환한 값 `"엘리스 토끼, 7"`을 화면에 출력합니다.
* **출력:**
  ```
  엘리스 토끼, 7
  ```

## ❗ 자주 하는 실수

* **`startswith('#')` 대신 `in '#'` 사용**: `'#' in log_item`은 문자열 내에 '#'이 포함되어 있는지 확인합니다. 문제에서는 '#'으로 *시작*하는지 확인해야 하므로 `startswith()`를 사용해야 합니다.
* **턴 번호 계산 오류**: 반환할 때 인덱스 `i`를 그대로 사용하면 0부터 시작하는 번호가 나옵니다. 문제에서는 1부터 시작하는 턴 수를 요구하므로 `i+1`을 사용해야 합니다.
* **반환 형식 오류**: `"엘리스 토끼, 7"` 형태를 정확히 맞춰야 합니다. 이름 오타, 쉼표 뒤 공백 누락, 추가적인 문자열 포함 등은 오답 처리될 수 있습니다. f-string을 사용하면 형식을 맞추기 편리합니다.
* **불필요한 반복**: 문제에서 '#'이 정확히 한 번 나온다고 보장했으므로, '#'을 찾으면 즉시 `return`하여 함수를 종료하는 것이 가장 효율적입니다. 모든 로그를 다 확인한 후 결과를 반환하도록 코드를 작성할 필요가 없습니다.
* **조건문 논리 오류**: 각 턴마다 `log1`과 `log2`를 모두 확인해야 하는데, 한 쪽만 확인하거나 순서를 잘못 배치하는 경우입니다. (현재 코드처럼 `if`-`elif` 구조로 순차 확인하는 것이 올바릅니다.)

문자열 메소드와 기본적인 제어문(for, if-elif)을 정확히 이해하고 사용하는 것이 중요한 문제입니다. 특히 문제의 제약 조건(정확히 한 번 등장)을 활용하여 코드를 효율적으로 작성하는 방법을 보여줍니다.