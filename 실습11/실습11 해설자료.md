## ✅ 핵심 개념 정리

이 문제를 해결하기 위해 필요한 파이썬의 주요 기능들을 먼저 살펴보겠습니다.

* **파일 처리 (`with open`, `for line in file`)**:
    * 텍스트 파일을 열고(`open`), 내용을 한 줄씩 효율적으로 읽어오는 방법입니다. `with` 구문을 사용하면 파일 사용 후 자동으로 닫아주어 편리합니다.
* **문자열 메소드**:
    * `strip()`: 문자열의 양 끝(시작과 끝)에 있는 불필요한 공백 문자(띄어쓰기, 탭, 줄바꿈 문자 `\n` 등)를 제거합니다. 파일에서 읽은 각 줄을 처리하기 전에 사용하면 좋습니다.
    * `split(구분자)`: 문자열을 주어진 `구분자`(이 문제에서는 `:`)를 기준으로 나누어 문자열들의 리스트로 만듭니다. 예: `"2020-08-01:엘리스 토끼".strip().split(':')` 결과는 `['2020-08-01', '엘리스 토끼']`.
* **튜플 언패킹 (Tuple Unpacking)**:
    * `변수1, 변수2 = 리스트나_튜플` 형태로, `split()` 등의 결과로 얻어진 리스트나 튜플의 각 요소를 개별 변수에 바로 할당하는 간결한 방법입니다.
* **딕셔너리 (Dictionary `{}`)**:
    * '키(Key)'와 '값(Value)'을 쌍으로 저장하는 자료구조입니다. 각 키는 고유해야 합니다.
    * 항목 추가/수정: `my_dict[key] = value`
    * `.values()`: 딕셔너리의 모든 값(Value)들만 모아서 볼 수 있는 뷰(view) 객체를 반환합니다. (Python 3 기준)
* **집합 (Set `{}`)**:
    * 순서가 없고, **중복된 요소를 허용하지 않는** 유일한 값들의 모음입니다.
    * `set(iterable)`: 리스트나 딕셔너리의 값 모음(`.values()`) 같은 반복 가능한 객체를 집합으로 만들 수 있습니다. 중복된 값은 자동으로 제거됩니다.
    * **주요 특징**: 특정 요소가 집합 안에 있는지 빠르게 확인할 수 있고(멤버십 테스트), 집합 간의 연산(교집합, 합집합, 차집합 등)이 매우 효율적입니다.
* **집합 연산**:
    * **교집합 (`&`)**: 두 집합에 **모두** 속하는 요소들로 이루어진 새로운 집합을 반환합니다. `set1 & set2` 형태로 사용합니다. (예: `{1, 2, 3} & {2, 3, 4}` 결과는 `{2, 3}`)

## ✅ 문제 해결 아이디어

문제의 목표는 간단합니다: 8월 방문객 명단 파일과 9월 방문객 명단 파일을 비교하여, 두 달 **모두 방문한 고객의 이름**을 찾는 것입니다.

가장 효율적인 해결 전략은 다음과 같습니다.

1.  **파일 -> 딕셔너리 변환 함수 (`txtToDict`)**: 각 파일을 읽어서 내용을 처리하기 좋은 형태로 바꾸는 함수를 만듭니다. 파일의 각 줄이 "날짜:이름" 형식이므로, 날짜를 키(key)로, 고객 이름을 값(value)으로 하는 딕셔너리로 만드는 것이 적절해 보입니다.
2.  **두 파일 처리**: 위에서 만든 `txtToDict` 함수를 사용하여 8월 파일과 9월 파일을 각각 딕셔너리로 변환합니다. (예: `eliceHotel8`, `eliceHotel9`)
3.  **고객 이름 추출**: 각 딕셔너리에서 **값(value)에 해당하는 고객 이름**들만 추출합니다. 딕셔너리의 `.values()` 메소드를 사용하면 됩니다.
4.  **집합(Set)으로 변환**: 추출된 고객 이름 목록(들)을 각각 **집합(Set)** 으로 변환합니다. 집합을 사용하는 이유:
    * 한 달에 여러 번 방문한 고객의 이름이 중복으로 여러 번 있어도 집합에는 **유일하게 한 번만** 저장됩니다.
    * 두 집합 간의 **교집합(`&`) 연산**을 사용하면, 두 달 모두 방문한 고객(즉, 두 집합 모두에 포함된 이름)을 매우 빠르고 간단하게 찾을 수 있습니다.
5.  **교집합 계산 및 반환**: 두 개의 고객 이름 집합의 교집합(`&`)을 계산합니다. 이 결과가 바로 두 달 모두 방문한 고객들의 이름 집합이며, 이 집합을 반환합니다.

## ✅ `txtToDict` 함수 구현 상세

이 함수는 파일명을 받아 딕셔너리를 반환합니다.

```python
def txtToDict(filename):
    userDict = {} # 빈 딕셔너리 생성
    with open(filename) as file: # 파일 열기 (with 사용으로 자동 닫기 보장)
        for line in file: # 파일을 한 줄씩 읽기
            # 1. line.strip(): 줄 끝의 \n 등 공백 제거
            # 2. .split(':'): ':' 기준으로 나누기 -> ['날짜', '이름'] 리스트 생성
            # 3. date, people = ...: 튜플 언패킹으로 변수에 바로 할당
            date, people = line.strip().split(':')
            # 4. userDict[날짜] = 이름 : 딕셔너리에 키-값 쌍으로 저장
            userDict[date] = people
    return userDict # 완성된 딕셔너리 반환
```
* 각 줄을 읽어 `strip()`과 `split(':')`으로 날짜와 이름을 분리하고, 튜플 언패킹으로 각각 `date`, `people` 변수에 저장한 후, `userDict`에 `날짜`를 키로, `이름`을 값으로 저장하는 과정을 반복합니다.

## ✅ `commonGuest` 함수 구현 상세

이 함수는 두 파일명을 받아 공통 고객 이름 집합을 반환합니다.

```python
def commonGuest(filename1, filename2):
    # 1. txtToDict 함수를 사용하여 각 파일을 딕셔너리로 변환
    eliceHotel8 = txtToDict(filename1)
    eliceHotel9 = txtToDict(filename2)

    # 2. 각 딕셔너리에서 값(고객 이름)들만 추출하여 집합(Set)으로 변환
    # .values()로 값들만 가져오고, set()으로 감싸 중복 제거 및 집합 생성
    eliceHotel8_value = set(eliceHotel8.values())
    eliceHotel9_value = set(eliceHotel9.values())

    # 3. 두 집합의 교집합(&)을 계산하여 반환
    # 두 집합 모두에 속하는 요소(이름)만 남음
    return eliceHotel8_value & eliceHotel9_value
```
* 핵심은 `.values()`로 이름 목록을 얻고, `set()`으로 집합을 만든 뒤, `&` 연산자로 교집합(공통 이름)을 찾는 것입니다.

## ✅ 전체 코드 구현

```python
elicehotel_8 = "EliceHotel_8.txt"
elicehotel_9 = "EliceHotel_9.txt"

# EliceHotel_8.txt과 EliceHotel_9.txt를 딕셔너리로 저장하기 위해 활용할 txtToDict함수를 정의합니다.
def txtToDict(filename):
    userDict = {}
    # 파일을 안전하게 열고 자동으로 닫기 위해 'with open' 사용
    with open(filename) as file:
        # 파일 내용을 한 줄씩 처리
        for line in file:
            # 각 줄의 양 끝 공백/줄바꿈 제거 후 ':' 기준으로 분리, 결과를 date와 people 변수에 저장
            date, people = line.strip().split(':')
            # 딕셔너리에 날짜를 키로, 방문객 이름을 값으로 저장
            userDict[date] = people
    # 완성된 딕셔너리 반환
    return userDict

# 2개의 txt 파일명을 입력받아 두 월 모두 방문한 손님을 탐색하는 함수 commonGuest를 정의합니다.
def commonGuest(filename1, filename2):
    # txtToDict 함수를 활용하여 txt파일을 딕셔너리로 저장합니다.
    eliceHotel8 = txtToDict(filename1)
    eliceHotel9 = txtToDict(filename2)

    # 8월 딕셔너리에서 값(방문객 이름)들만 추출하여 집합으로 만듭니다. (중복 자동 제거)
    eliceHotel8_value = set(eliceHotel8.values())
    # 9월 딕셔너리에서 값(방문객 이름)들만 추출하여 집합으로 만듭니다.
    eliceHotel9_value = set(eliceHotel9.values())

    # 두 집합의 교집합(& 연산자)을 구하여, 두 달 모두 방문한 고객 이름 집합을 반환합니다.
    return eliceHotel8_value & eliceHotel9_value

# commonGuest 함수를 호출하고 결과를 출력합니다.
print(commonGuest(elicehotel_8, elicehotel_9))
```

## 🧾 입출력 예시 설명

* `EliceHotel_8.txt`를 `txtToDict`로 처리하면 `{..., '2020-08-01': '엘리스 토끼', '2020-08-02': '모자장수', ...}` 와 같은 딕셔너리가 됩니다.
* `EliceHotel_9.txt`를 `txtToDict`로 처리하면 `{..., '2020-09-05': '엘리스 토끼', '2020-09-10': '도도새', ...}` 와 같은 딕셔너리가 됩니다.
* `set(eliceHotel8.values())`는 `{'엘리스 토끼', '모자장수', '체셔 고양이', '행인', '캐터필러', ...}` (8월 방문객 이름 집합)이 됩니다.
* `set(eliceHotel9.values())`는 `{'엘리스 토끼', '도도새', ...}` (9월 방문객 이름 집합, 만약 9월 파일에 토끼만 있다면) 이 됩니다.
* `eliceHotel8_value & eliceHotel9_value`는 두 집합의 교집합, 즉 양쪽 모두에 있는 이름인 `{'엘리스 토끼'}`를 계산합니다.
* `print()` 함수가 이 최종 집합 `{'엘리스 토끼'}`를 출력합니다.

## ❗ 자주 하는 실수

* **파일 경로 및 이름 오류**: `EliceHotel_8.txt` 또는 `EliceHotel_9.txt` 파일이 코드 실행 위치에 없거나 이름이 다르면 `FileNotFoundError`가 발생합니다.
* **파일 인코딩 문제**: 만약 파일에 한글 이름 등이 포함되어 있고 시스템 기본 인코딩과 파일 인코딩이 다르면 글자가 깨지거나 오류가 발생할 수 있습니다. `open(filename, encoding='utf-8')` 처럼 인코딩을 명시하는 것이 더 안전합니다.
* **파일 형식 오류 처리 미흡**: 파일 내에 ':'가 없는 줄, 빈 줄 등이 있을 경우 `line.strip().split(':')` 부분에서 `ValueError` (언패킹할 요소 개수 불일치) 등이 발생할 수 있습니다. (정답 코드에는 별도 오류 처리가 없지만, 실제 상황에서는 고려가 필요합니다.)
* **딕셔너리 키/값 혼동**: 날짜 대신 이름을 키로 사용하거나, 값을 잘못 추출하는 경우입니다.
* **집합(Set) 미사용**: `.values()`로 얻은 결과를 리스트 상태로 두고 반복문 등으로 직접 비교하여 공통 요소를 찾으려고 하면 코드가 훨씬 복잡해지고 비효율적입니다. 집합의 교집합 연산(`&`)을 사용하는 것이 핵심입니다.
* **잘못된 집합 연산 사용**: 교집합(`&`) 대신 합집합(`|`, 모든 방문객), 차집합(`-`, 한쪽에만 있는 방문객) 등을 사용하면 문제의 요구사항과 다른 결과를 얻게 됩니다.
* **`.values()` 누락**: `set(eliceHotel8)` 처럼 딕셔너리 자체를 `set()`에 넣으면 키(날짜)들이 집합으로 만들어집니다. 값(이름)을 원하므로 반드시 `.values()`를 사용해야 합니다.