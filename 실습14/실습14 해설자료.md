# 실습14 해설자료
## ✅ 핵심 개념 정리 (Python)

이 문제는 CSV 파일을 읽고 데이터를 처리하여 조건에 맞는 결과를 정렬하는 작업입니다. 다음과 같은 파이썬 기능들을 활용합니다.

* **CSV 파일 읽기 (`csv` 모듈)**:
    * CSV(Comma-Separated Values) 파일은 쉼표(,)로 데이터를 구분하는 텍스트 파일 형식입니다. 데이터 안에 쉼표가 포함된 경우 등을 올바르게 처리하기 위해 파이썬의 내장 `csv` 모듈을 사용하는 것이 좋습니다.
    * `import csv`: `csv` 모듈을 사용하기 위해 먼저 가져옵니다.
    * `open(filename, 'r', encoding='utf-8', newline='')`: 파일을 읽기 모드('r')로 엽니다.
        * `encoding='utf-8'`: 파일에 한글이나 다양한 문자가 포함될 수 있으므로 인코딩을 UTF-8로 지정하는 것이 안전합니다.
        * `newline=''` : CSV 파일을 다룰 때 운영체제 간의 줄바꿈 문자 처리 방식 차이로 인해 발생할 수 있는 문제를 방지하기 위해 권장되는 옵션입니다.
    * `csv.reader(파일객체)`: 열린 파일 객체를 인자로 받아, 파일을 한 줄씩 읽어 각 줄의 데이터를 쉼표 기준으로 분리된 **리스트**로 만들어주는 반복 가능한 객체(iterator)를 생성합니다. (예: `['댓글수', '부가설명', ...]`)
    * `f.close()`: 파일을 다 사용한 후에는 닫아주는 것이 좋습니다. (더 권장되는 방식은 `with open(...) as f:` 구문을 사용하여 자동으로 파일을 닫는 것입니다.)
* **리스트(List)와 튜플(Tuple)**:
    * `csv.reader`가 반환하는 각 줄은 리스트 형태입니다. 리스트의 각 요소(컬럼 데이터)는 **인덱스**(`[0]`, `[1]`, ...)로 접근합니다. 문제에서 열 번호(인덱스) 정보가 주어졌으므로 이를 활용합니다.
    * 최종 결과를 저장할 때 `(제목, 조회수)` 형태의 **튜플**을 사용합니다. 튜플은 변경할 수 없는(immutable) 자료형으로, 여러 값을 하나로 묶을 때 자주 사용됩니다.
    * 리스트(`talks`, `result`)는 이러한 튜플들을 담는 컨테이너로 사용됩니다.
* **타입 변환 (`int()`)**:
    * CSV 파일에서 읽어온 모든 데이터는 기본적으로 **문자열(string)** 타입입니다. 조회수처럼 숫자여야 하는 값은 계산(비교, 정렬)을 위해 `int()` 함수를 사용하여 정수(integer) 타입으로 변환해야 합니다.
* **리스트 컴프리헨션 (List Comprehension)**:
    * `[표현식 for 항목 in 반복가능객체 if 조건문]` 형태로, 기존 리스트를 기반으로 특정 조건을 만족하는 요소들만 뽑아내어 **새로운 리스트**를 간결하게 만드는 방법입니다. 필터링 작업에 매우 유용합니다.
* **리스트 정렬 (`list.sort()` 메소드)**:
    * 리스트 자체를 **내부적으로(in-place)** 정렬합니다. 반환값은 `None`입니다.
    * `key=함수`: 정렬 기준을 지정하는 함수를 전달합니다. 리스트의 각 요소에 이 함수를 적용한 결과를 기준으로 정렬합니다.
    * **`lambda` 함수**: `key` 값으로 간단한 함수를 즉석에서 만들어 사용할 때 유용합니다. `lambda 매개변수: 표현식` 형태로 작성합니다. `lambda x: x[1]`은 리스트의 각 요소 `x`(여기서는 튜플)를 받아서 그 **두 번째 요소(`x[1]`, 즉 조회수)**를 반환하는 함수이며, 이 조회수를 기준으로 정렬하라는 의미입니다.
    * `reverse=True`: 내림차순(큰 값부터 작은 값 순서)으로 정렬하도록 지정합니다. 기본값은 `False`(오름차순)입니다.

## ✅ 문제 해결 아이디어

문제의 목표는 `ted.csv` 파일에서 조회수가 `n` 이상인 강연들을 찾아, 그 강연의 `(제목, 조회수)` 튜플로 이루어진 리스트를 **조회수 기준 내림차순**으로 정렬하여 반환하는 것입니다.

정답 코드의 해결 전략은 다음과 같습니다.

1.  **CSV 파일 읽기 설정**: `csv` 모듈을 import하고, `ted.csv` 파일을 `utf-8` 인코딩과 `newline=''` 옵션을 사용하여 읽기 모드로 엽니다. `csv.reader`를 사용하여 파일 내용을 줄 단위 리스트로 읽을 준비를 합니다.
2.  **데이터 추출 및 저장**: 파일을 한 줄씩 반복하며 읽습니다. 각 줄(리스트 `line`)에서 필요한 데이터인 제목(`line[14]`)과 조회수(`line[16]`)를 인덱스로 추출합니다. 조회수는 `int()`로 정수 변환한 후, `(제목, 조회수)` 튜플로 만들어 `talks` 리스트에 `append`합니다.
3.  **파일 닫기**: 모든 줄을 읽었으면 파일을 닫습니다 (`f.close()`).
4.  **필터링**: `talks` 리스트에 저장된 모든 튜플들을 대상으로, 조회수(튜플의 두 번째 요소)가 입력받은 `n` 이상인 튜플들만 걸러내어 `result` 리스트를 생성합니다. 리스트 컴프리헨션을 사용하면 이 과정을 간결하게 작성할 수 있습니다.
5.  **정렬**: 필터링된 `result` 리스트를 `sort()` 메소드를 이용하여 정렬합니다. 정렬 기준(`key`)은 각 튜플의 두 번째 요소(조회수)가 되도록 `lambda x: x[1]` 함수를 사용하고, 내림차순(`reverse=True`)으로 정렬합니다.
6.  **결과 반환**: 최종적으로 정렬된 `result` 리스트를 반환합니다.

## ✅ `get_popular_speaking` 함수 구현 상세

정답 코드의 각 부분을 단계별로 자세히 설명합니다.

1.  **모듈 임포트 및 초기화**:
    ```python
    import csv
    # import json # (정답 코드엔 있지만 실제 사용되지 않음)

    def get_popular_speaking(n) :
        talks = [] # 결과를 담을 빈 리스트
    ```

2.  **파일 열기 및 CSV Reader 생성**:
    ```python
    # ted.csv 파일을 읽기 모드('r')로, utf-8 인코딩으로, newline='' 옵션으로 엶
    f = open('ted.csv', 'r', encoding='utf-8', newline='')
    # csv 파일을 읽기 위한 reader 객체 생성
    reader = csv.reader(f)
    ```
    * `encoding='utf-8'`은 다양한 문자를 문제없이 읽기 위함이고, `newline=''`은 CSV 처리 시 권장됩니다.

3.  **데이터 읽기 및 튜플 생성/저장**:
    ```python
    # reader 객체를 통해 CSV 파일을 한 줄씩 읽음 (각 line은 리스트)
    for line in reader:
        # line[14]는 제목(str), line[16]은 조회수(str)
        # 조회수는 int()로 정수 변환 후 (제목, 조회수) 튜플로 묶어 talks 리스트에 추가
        talks.append((line[14], int(line[16])))
    ```
    * 각 줄에서 14번 인덱스(제목)와 16번 인덱스(조회수) 값을 가져옵니다. 조회수는 `int()`로 변환하는 것이 핵심입니다.

4.  **파일 닫기**:
    ```python
    f.close() # 파일 사용이 끝났으므로 닫아줌
    ```
    * 파일을 직접 `open()`으로 열었을 경우, `close()`를 호출하여 리소스를 해제하는 것이 중요합니다. (`with open(...)` 구문을 사용하면 자동으로 닫힙니다.)

5.  **필터링 (리스트 컴프리헨션)**:
    ```python
    # talks 리스트의 각 튜플 t에 대해, t[1](조회수)이 n 이상인 경우만 골라 result 리스트 생성
    result = [t for t in talks if t[1] >= n]
    ```
    * `talks` 리스트를 순회하며 조건(`t[1] >= n`)을 만족하는 튜플 `t`만으로 새로운 `result` 리스트를 만듭니다.

6.  **정렬**:
    ```python
    # result 리스트를 내부적으로 정렬 (in-place sort)
    # key=lambda x: x[1] : 각 요소 x(튜플)의 두 번째 값 x[1](조회수)를 기준으로 정렬
    # reverse=True : 내림차순 (조회수 높은 순)으로 정렬
    result.sort(key=lambda x: x[1], reverse=True)
    ```
    * `lambda x: x[1]`은 "각 튜플 `x`가 주어지면 그것의 1번 인덱스 값(조회수)을 기준으로 삼아라" 라는 의미의 임시 함수입니다.

7.  **결과 반환**:
    ```python
    return result # 정렬된 최종 리스트를 반환
    ```

## ✅ 전체 코드 구현

```python
import csv
# import json # 이 문제에서는 사용되지 않음

def get_popular_speaking(n) :
    talks = [] # (제목, 조회수) 튜플을 저장할 리스트
    # 파일을 열고 csv reader 준비 (with 구문 사용 권장)
    # encoding='utf-8' : 다양한 문자 처리
    # newline='' : csv 처리 시 권장 옵션
    f = open('ted.csv', 'r', encoding='utf-8', newline='')
    reader = csv.reader(f)

    # csv 파일 한 줄씩 읽기 (각 line은 컬럼 값들의 리스트)
    for line in reader:
        try: # 혹시 모를 인덱스 오류나 타입 변환 오류 방지 (선택 사항)
            title = line[14]       # 14번 인덱스: 강연 제목 (문자열)
            views = int(line[16]) # 16번 인덱스: 조회수 (문자열 -> 정수 변환)
            talks.append((title, views)) # (제목, 조회수) 튜플로 만들어 리스트에 추가
        except (IndexError, ValueError) as e:
            # 실제 데이터 처리 시에는 오류 로그 등을 남기는 것이 좋음
            # print(f"Skipping line due to error: {e} - Line: {line}")
            pass # 이 문제에서는 오류 라인 건너뛰기

    f.close() # 파일 닫기

    # 리스트 컴프리헨션: talks 리스트에서 조회수(t[1])가 n 이상인 튜플 t만 필터링
    result = [t for t in talks if t[1] >= n]

    # 필터링된 result 리스트를 정렬
    # key=lambda x: x[1] : 튜플의 두 번째 요소(조회수) 기준
    # reverse=True : 내림차순 (높은 조회수 우선)
    result.sort(key=lambda x: x[1], reverse=True)

    # 최종 결과 리스트 반환
    return result

# main 함수는 제공된 스켈레톤 코드와 동일
def main():
    n = int(input())
    print(get_popular_speaking(n))

if __name__ == "__main__":
    main()
```
*(오류 처리 `try-except` 부분은 안정성을 위해 추가되었으며, 문제 풀이의 핵심은 아닙니다.)*

## 🧾 입출력 예시 설명

* **입력:** `40000000` (n = 40,000,000)
* **처리 과정:**
    1.  `ted.csv` 파일을 읽어 모든 강연의 `(제목_문자열, 조회수_정수)` 튜플을 `talks` 리스트에 저장합니다.
    2.  리스트 컴프리헨션 `[t for t in talks if t[1] >= 40000000]`을 통해 조회수가 4천만 이상인 튜플만 `result` 리스트에 남깁니다. (예: `[('Do schools kill creativity?', 47227110), ('Your body language may shape who you are', 43155405)]` 등이 포함될 것입니다.)
    3.  `result.sort(key=lambda x: x[1], reverse=True)`를 통해 `result` 리스트를 튜플의 두 번째 요소(조회수) 기준으로 내림차순 정렬합니다. (47,227,110 > 43,155,405 이므로 순서가 유지되거나 결정됩니다.)
    4.  최종적으로 정렬된 `result` 리스트 `[('Do schools kill creativity?', 47227110), ('Your body language may shape who you are', 43155405)]` 가 반환되고 출력됩니다.

## ❗ 자주 하는 실수

* **`csv` 모듈 미사용**: CSV 파일을 일반 텍스트처럼 다루면 데이터 내 쉼표나 따옴표 처리에서 예기치 않은 오류가 발생할 수 있습니다. `csv.reader` 사용이 권장됩니다.
* **파일 인코딩/`newline` 옵션 누락**: 파일 내용이나 실행 환경에 따라 오류가 발생하거나 데이터가 잘못 읽힐 수 있습니다. `encoding='utf-8'`, `newline=''` 사용을 습관화하는 것이 좋습니다.
* **인덱스 번호 오류**: 제목(14)과 조회수(16)의 인덱스를 잘못 사용하면 엉뚱한 데이터를 가져오게 됩니다. (0부터 시작하는 인덱스!)
* **조회수 타입 변환(`int()`) 누락**: CSV에서 읽은 조회수는 문자열입니다. `int()`로 변환하지 않으면 숫자 비교(`>= n`)나 숫자 기준 정렬이 불가능하거나 잘못된 결과를 낳습니다. (예: 문자열 비교 "500" > "40000000" 은 True)
* **필터링 조건 오류**: `if t[1] >= n` 조건을 잘못 작성하는 경우 (예: `t[0] >= n` 또는 비교 연산자 오류).
* **정렬 로직 오류**:
    * `key`를 지정하지 않으면 튜플의 첫 번째 요소(제목) 기준으로 정렬됩니다.
    * `key=lambda x: x[1]`을 정확히 사용하지 못하는 경우 (예: `x[0]` 사용).
    * `reverse=True`를 빼먹으면 오름차순(조회수 낮은 순)으로 정렬됩니다.
* **파일 닫기 누락**: `f.close()`를 호출하지 않거나 `with open` 구문을 사용하지 않으면 파일 리소스가 제대로 해제되지 않을 수 있습니다. (작은 프로그램에서는 문제가 안 될 수도 있지만 좋은 습관은 아닙니다.)

CSV 파일 처리, 데이터 추출 및 변환, 리스트 컴프리헨션을 이용한 필터링, `lambda`를 이용한 정렬 등 파이썬 데이터 처리의 여러 기본 기법을 연습할 수 있는 문제입니다.